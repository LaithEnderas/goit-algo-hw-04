# Звіт до завдання 3

## Мета роботи
Метою роботи є проведення емпіричного порівняння трьох алгоритмів сортування:  
- сортування злиттям (Merge Sort)  
- сортування вставками (Insertion Sort)  
- вбудованого алгоритму Python (Timsort), який реалізовано у функціях `sorted()` та `list.sort()`  

Порівняння здійснюється за часом виконання для різних обсягів вхідних даних. Також виконується перевірка відповідності експериментальних результатів теоретичним оцінкам складності.

---

## Теоретичні відомості
Алгоритми сортування мають різну асимптотичну складність:

| Алгоритм         | Найкращий випадок | Середній випадок | Найгірший випадок |
|------------------|--------------------|------------------|-------------------|
| Insertion Sort   | O(n)              | O(n²)            | O(n²)             |
| Merge Sort       | O(n log n)        | O(n log n)       | O(n log n)        |
| Timsort (Python) | O(n)              | O(n log n)       | O(n log n)        |

Timsort поєднує два підходи:  
- сортування вставками для малих підмасивів  
- злиття для об’єднання впорядкованих частин  

Завдяки цьому алгоритм є адаптивним та забезпечує високу продуктивність на реальних наборах даних.

---

## Методика дослідження
Для дослідження було використано модуль `timeit`, який дозволяє вимірювати час виконання функцій.  
Алгоритми тестувалися на випадкових наборах цілих чисел трьох розмірів:
- N = 100
- N = 1000
- N = 5000

Для кожного алгоритму вимірювався час виконання однієї операції сортування.

---

## Результати експерименту

| Розмір масиву (N) | Merge Sort (с) | Insertion Sort (с) | Timsort (с) |
|-------------------|-----------------|---------------------|--------------|
| 100               | 0.00012         | 0.00016             | 0.00001      |
| 1000              | 0.00136         | 0.01434             | 0.00008      |
| 5000              | 0.00866         | 0.35648             | 0.00037      |

---

## Аналіз результатів
1. Для малих обсягів даних (N = 100) усі алгоритми демонструють високу швидкість виконання. Проте вже на цьому етапі вбудований алгоритм Timsort є найшвидшим.
2. Зі збільшенням розміру даних сортування вставками істотно втрачає ефективність, що підтверджує його квадратичну складність O(n²).
3. Сортування злиттям показує стабільну ефективність зі складністю O(n log n).
4. Алгоритм Timsort демонструє найкращі результати завдяки адаптивній структурі, поєднанню швидкої обробки впорядкованих підпослідовностей та оптимальному злиттю.

---

## Висновки
1. Теоретичні оцінки складності підтверджені експериментально.  
2. Алгоритм сортування вставками є непридатним для великих обсягів даних через квадратичну складність.  
3. Сортування злиттям забезпечує стабільний час виконання, але поступається Timsort за швидкодією.  
4. Вбудований алгоритм Python (Timsort) є найефективнішим серед розглянутих завдяки комбінації двох підходів — злиття та вставок.  
5. Для практичного використання доцільно застосовувати саме стандартні функції Python `sorted()` або `list.sort()`, оскільки вони оптимізовані для більшості сценаріїв.
